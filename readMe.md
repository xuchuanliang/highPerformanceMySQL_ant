# 《高性能MySQL（第三版）》

## 第一章 MySQL架构与历史
- 客户端-->连接/线程处理-->解析器/查询缓存-->查询缓存/优化器-->存储引擎
- 共享锁/排他锁，也叫读锁/写锁：读锁是共享的，或者或是相互不堵塞的。多个客户可以在同一时刻读取同一资源，而互不干扰。写锁则是排他的，也就是说一个写锁可以阻止其他写锁
或读锁，这是出于安全的考虑，只有这样，才能确保在给定的时间内，只能有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。
#### 1.2.2 锁粒度
>一种提高资源并发性的方式就是让锁对象更有选择性。尽量只锁定需要修改的的部分数据，而不是所有资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上
，锁定的数据量越少，则系统的并发性越高，只要相互之间不发生冲突即可。
所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响性能。
- 表锁、行级锁
### 1.3 事务
- 事务的ACID：原子性（atomicity），一致性（consistency），隔离性（isolation），持久性（durability）
- 隔离级别：
READ UNCOMMITTED（未提交读）：在READ COMMITTED级别，事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读到未提交的数据，也被称为脏读。一般很少用

READ COMMITTED（提交读）：一个事务在开始提交前，所做的任何修改对其他事务都是不可见的，这个级别有时候也叫做不可重复读，两次重复的查询可能查到不相同的结果。

REPEATABLE READ（可重复读）：解决了脏读问题，保证了同一个事务中多次读取同样的记录结果是一样的，但是无法解决幻读问题。幻读，是指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内
插入了新的记录，当之前的事务在读取再次读取该范围内记录时，会产生幻行。
可重复读是mysql的默认隔离级别。

SERIALIZABLE（可串行化）：它通过强制事务串行执行，避免的幻读问题，简单说，SERIALIZABLE会在读取的每一行上加锁，会导致大量超时和锁征用问题，导致性能损耗比较严重，一般也比较少的用到。

####1.3.2 死锁
####1.3.3 事务日志
####1.3.4 MySQL中的事务
- MySQL提供两种事务型的存储引擎：InnoDB和NDB Cluster
- InnoDB采用的是两阶段锁定协议，在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。

### 1.4 多版本并发控制
- MySQL、Orcal、PostgreSQL一般都同时实现了多版本并发控制（MVCC）
> MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻
看到的数据可能是不一样的。   
>典型的有乐观并发控制和悲观并发控制，下面通过InnoDB的简化版行为来说明MVCC如何工作的：InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行
的创建时间，一个保存了行的过期时间（删除时间）。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号会自动递增。事务开始时刻的系统版本号会作为
事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的：
>>SELECT : InnoDB会根据以下两个条件检查每行记录：a.InnoDB只查找版本早于当前事务版本的数据行（也就是行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行
，要么是在事务开始前就已经存在的，要么是事务自身插入或者修改过的。b.行的删除版本要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。
>>>INSERT : InnoDB为新插入的每一行保存当前系统版本号作为行版本号
>>>InnoDB为删除的每一行保存当前系统版本号作为行删除标识
>>>UPDATE : InnoDB为插入的一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。
>保存这两个额外系统版本号，使大多数操作都可以不用加锁，这样设计性能很好。

### 1.5 MySQL的存储引擎
- 在文件系统下，MySQL将每个数据库（也可以称为schema）保存为数据目录下一个子目录，创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。
可以使用SHOW TABLE STATUS LIKE '表名';查看表的相关信息。包含：Name/Engine/Version/Row_format/Rows/Avg_row_length/Data_length/Max_data_length/Index_length/Data_free/Auto_increment/Create_time/Update_time/Check_time/Collation/Checksum/Create_options/Comment
2019年1月24日 22:16:38  53/801
#### 1.5.1 InnoDB存储引擎
>InnoDB采用MVCC来支持高并发，并且实现四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁策略防止幻读的出现。间隙锁使的InnoDB不仅仅锁定查询涉及的行，
还会对索引中的间隙进行锁定，以防止幻影行的插入。InnoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过他的二级索引（非主键索引）中必须包含主键列，所以如果主键列很大
的话，其他的索引都会很大。InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作
的插入缓冲区等。

- 修改表的存储引擎：1.ALTER TABLE 表名 ENGINE = InnoDB;2.使用mysqldump导出--》修改sql语句--》导入；3.创建与查询：创建一个新的相同格式的表，使用要求的存储引擎，然后通过INSERT INTO 表名 select * from 表名
2019年1月30日 16:02:23 72/801

## 第二章 MySQL基准测试
- 基准测试是针对系统设计的一种压力测试，sysbench是一款非常优秀的MySQL基准测试工具

### 2.1 为什么需要基准测试

### 2.2 基准测试的策略
>基准测试有两种主要的策略：一是针对整个系统的整体测试；另外是单独测试MySQL。这两种策略也被称为集成式以及单组件式基准测试。
#### 2.2.1 测试何种指标
2019年2月12日 12:25:47 75/801

## 第三章 服务器性能剖析

## 第四章 Schema与数据类型优化

## 第五章 创建高性能的索引

## 第六章 查询性能优化

## 第七章 MySQL高级特性

## 第八章 优化服务器设置

## 第九章 操作系统和硬件优化

## 第十章 复制

## 第十一章 可扩展的MySQL

## 第十二章 高可用性

## 第十三章 云端的MySQL

## 第十四章 应用层优化

## 第十五章 备份与恢复

## 第十六章 MySQL用户工具
