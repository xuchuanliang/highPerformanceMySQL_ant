# 《高性能MySQL（第三版）》

## 第一章 MySQL架构与历史
- 客户端-->连接/线程处理-->解析器/查询缓存-->查询缓存/优化器-->存储引擎
- 共享锁/排他锁，也叫读锁/写锁：读锁是共享的，或者或是相互不堵塞的。多个客户可以在同一时刻读取同一资源，而互不干扰。写锁则是排他的，也就是说一个写锁可以阻止其他写锁
或读锁，这是出于安全的考虑，只有这样，才能确保在给定的时间内，只能有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。
#### 1.2.2 锁粒度
>一种提高资源并发性的方式就是让锁对象更有选择性。尽量只锁定需要修改的的部分数据，而不是所有资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上
，锁定的数据量越少，则系统的并发性越高，只要相互之间不发生冲突即可。
所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响性能。
- 表锁、行级锁
### 1.3 事务
- 事务的ACID：原子性（atomicity），一致性（consistency），隔离性（isolation），持久性（durability）
- 隔离级别：
READ UNCOMMITTED（未提交读）：在READ COMMITTED级别，事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读到未提交的数据，也被称为脏读。一般很少用

READ COMMITTED（提交读）：一个事务在开始提交前，所做的任何修改对其他事务都是不可见的，这个级别有时候也叫做不可重复读，两次重复的查询可能查到不相同的结果。

REPEATABLE READ（可重复读）：解决了脏读问题，保证了同一个事务中多次读取同样的记录结果是一样的，但是无法解决幻读问题。幻读，是指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内
插入了新的记录，当之前的事务在读取再次读取该范围内记录时，会产生幻行。
可重复读是mysql的默认隔离级别。

SERIALIZABLE（可串行化）：它通过强制事务串行执行，避免的幻读问题，简单说，SERIALIZABLE会在读取的每一行上加锁，会导致大量超时和锁征用问题，导致性能损耗比较严重，一般也比较少的用到。

####1.3.2 死锁
####1.3.3 事务日志
####1.3.4 MySQL中的事务
- MySQL提供两种事务型的存储引擎：InnoDB和NDB Cluster
- InnoDB采用的是两阶段锁定协议，在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。
 2019年1月21日 22:16:36 49/801



## 第二章 MySQL基准测试

## 第三章 服务器性能剖析

## 第四章 Schema与数据类型优化

## 第五章 创建高性能的索引

## 第六章 查询性能优化

## 第七章 MySQL高级特性

## 第八章 优化服务器设置

## 第九章 操作系统和硬件优化

## 第十章 复制

## 第十一章 可扩展的MySQL

## 第十二章 高可用性

## 第十三章 云端的MySQL

## 第十四章 应用层优化

## 第十五章 备份与恢复

## 第十六章 MySQL用户工具
